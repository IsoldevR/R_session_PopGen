---
title: "R Session Population Genetics"
output: html_notebook
---
Install the following packages.
For the sequence data manipulation and missingness plotting:
seqinr
gplots
RColorBrewer

For the population genetics statistics:
adegenet
pegas

##Remove if we don't use pophelper:
#Cairo
#ggplot2
#gridExtra
#gtable
#tidyr
#devtools

```{r}
#For sequence data manipulation and missingness plotting:
library(seqinr)
library(gplots)
library(RColorBrewer)
library(graphics)

#For LD, PCA etc.:
library(adegenet)
library(pegas)

#For structure mapping:
#library(Cairo)
#library(ggplot2)
#library(gridExtra)
#library(gtable)
#library(tidyr)
#library(devtools)

##HOW TO MAKE THIS RUN WITHOUT THE OUTPUT BELOW?
```

FILE FORMATS
  FASTA
    seqinr
    With the package seqinr you can read in a fasta file.
    Below you see an example where I used a aligned fasta file, checked whether the triplicated        samples (library in triplicate, treated as separate samples during assembly) had differences in     their sequence between replicates of individuals, or whether differences could be attritbuted      to missing data.
    
```{r}
##FASTA
#Read data 
original<-read.fasta("RAD_Bufo_replicated_individuals.fasta", as.string=TRUE, set.attributes = FALSE)

##For loop integrating - and n
#Make empty matrices for loop
Out_Perc_diff<-matrix(nrow=length(original), ncol=0)
Out_Perc_no_worries<-matrix(nrow=length(original), ncol=0)

#Loop trough the fasta  file
for (i in 1:length(original)){
  #Make empty vectors for second loop
  col_diff<-c()
  col_no_worries<-c()
  Seq_1<-getSequence(original[[i]])
  
  for (j in 1:length(original)){
    #Get raw percentage of difference between sequences, includes ALL differences
    Seq_2<-getSequence(original[[j]])
    Same<-sum(Seq_1==Seq_2, na.rm=TRUE)          #All positions which are equal
    Diff<-sum(!Seq_1==Seq_2, na.rm=TRUE)         #All positions which are different
    stopifnot((Same+Diff)==length(Seq_1))        #Check
  
    Perc_diff<-(Diff/length(Seq_1))
    
    #Get percentage of difference because of N
    Seq_1_N<-Seq_1=="n"
    Seq_2_N<-Seq_2=="n"
    
    #Get percentage of difference because of -
    Seq_1_I<-Seq_1=="-"
    Seq_2_I<-Seq_2=="-"
    
    #Get the exceptions, the differences we are not afraid of (missing data: N and -)
    #The - (indel) in paired end is very common when not sequencing the whole selected fragment
    Diff_no_w_1<-sum(!Seq_1_N==Seq_2_N, na.rm=TRUE)
    Diff_no_w_2<-sum(!Seq_1_I==Seq_2_I, na.rm=TRUE)
    Diff_no_w_3<-sum(Seq_1_N==TRUE & Seq_1_N==Seq_2_I | Seq_1_I==TRUE & Seq_1_I==Seq_2_N, na.rm=TRUE)
    
    Perc_no_worries<-(((Diff_no_w_1+Diff_no_w_2)-Diff_no_w_3)/length(Seq_1))
    
    #Add the numbers to make a column
    col_diff<-c(col_diff, Perc_diff)
    col_no_worries<-c(col_no_worries, Perc_no_worries)
  }
  #Add the columns to the matrix
  Out_Perc_diff<-cbind(Out_Perc_diff, col_diff)
  Out_Perc_no_worries<-cbind(Out_Perc_no_worries, col_no_worries)
}

#Add rownames to the matrices, mainly for the figures
rownames(Out_Perc_diff)<-names(original)
colnames(Out_Perc_diff)<-names(original)
rownames(Out_Perc_no_worries)<-names(original)
colnames(Out_Perc_no_worries)<-names(original)

# Calculate what we came for: the actual number of 'wrongly' called SNPs!
Diff_worry<-Out_Perc_diff-Out_Perc_no_worries

All_diff<-c(Diff_worry['1572_A','1572_B'], Diff_worry['1572_B','1572_C'],Diff_worry['1572_A','1572_C'],
  Diff_worry['1573_A','1573_B'], Diff_worry['1573_B','1573_C'],Diff_worry['1573_A','1573_C'],
  Diff_worry['1574_A','1574_B'], Diff_worry['1574_B','1574_C'],Diff_worry['1574_A','1574_C'],
  Diff_worry['4112_A','4112_B'], Diff_worry['4112_B','4112_C'],Diff_worry['4112_A','4112_C'],
  Diff_worry['4113_A','4113_B'], Diff_worry['4113_B','4113_C'],Diff_worry['4113_A','4113_C'],
  Diff_worry['4114_A','4114_B'], Diff_worry['4114_B','4114_C'],Diff_worry['4114_A','4114_C']
  )
mean(All_diff)


```

Good, we can see that only a very small portion (<1%) of the differences between the replicates of individuals is due to an actually different nucleotide.

Now I want to visualise this with a heatmap. ##THIS DOESN'T EXECUTE WELL IN MARKDOWN

```{r}
##Make heat tables to compare between the influence of real mistakes vs missing data
#Make a panel figure for both tables 
par(mfrow = c(1,2), mai = c(.7, .7, .1, .1)) #mfrow = c(1,2) gives you two colums

#Adapt this code so the color breaks fit with your data
my_palette <- colorRampPalette(c("green", "yellow", "red"))(n = 299)

#Defines the color breaks manually for a "skewed" color transition
col_breaks = c(seq(0,.3,length=100),                 # for green
               seq(0.3001,0.6,length=100),            # for yellow
               seq(.6001,.9,length=100))             # for red

###HELP! THIS ONLY WORKS OUTSIDE THE RMD!
#Figure 1: the influence of missing data
dim <- ncol(Out_Perc_no_worries)
image(1:dim, 1:dim, Out_Perc_no_worries, axes = FALSE, xlab="", ylab="", col=my_palette, breaks=col_breaks)
axis(1, 1:dim, colnames(Out_Perc_no_worries), cex.axis = 0.7, las=3)
axis(2, 1:dim, colnames(Out_Perc_no_worries), cex.axis = 0.7, las=1)
text(expand.grid(1:dim, 1:dim), sprintf("%0.2f", Out_Perc_no_worries), cex=0.54)

#Figure 2: the influence of 'real' differences between sequences
dim <- ncol(Diff_worry)
image(1:dim, 1:dim, Diff_worry, axes = FALSE, xlab="", ylab="", col=my_palette, breaks=col_breaks)
axis(1, 1:dim, colnames(Diff_worry), cex.axis = 0.7, las=3)
axis(2, 1:dim, colnames(Diff_worry), cex.axis = 0.7, las=1)
text(expand.grid(1:dim, 1:dim), sprintf("%0.2f", Diff_worry), cex=0.54)

```
  VCF
    vcfR
    To read in and manipulate a vcf file, one can use the R package vcfR:
    https://cran.r-project.org/web/packages/vcfR/vignettes/intro_to_vcfR.html
    
  BAM/SAM
    scanBam
    To import, count, index, filter, sort, and merge BAM files:
    https://rdrr.io/bioc/Rsamtools/man/scanBam.html
    
    Rsamtools
    To read in and manipulate a BAM/SAM file, one can use the R package Rsamtools:
    https://kasperdanielhansen.github.io/genbioconductor/html/Rsamtools.html

Data filtering 
  It is nice to be able to filter your data manually. This allows you to understand better what you are working with. Examples of SNPs that you might want to filter out are singletons. Or you might want to work with only the di-allelic SNPs in your dataset, because many softwares only utilise di-allelic SNPs. In my case, I wanted to see which SNPs were present as one variant in one of my species, and as another in another species. With these SNPs I would be able to analyse the hybrids between both species. In the next code, I filtered my data for such 'species specific' SNPs based on my assumed 'pure' populations.

##NOTE: add a map at this point for checking the populations?
```{r}
##To take out the population specific SNPs from a table
#Read in my SNPs
SNPtable<-as.data.frame(read.table("RAD_Bufo_SNPtable.txt", header=TRUE))

## Remove columns where one species only has NA (possibly null aleles)
#change the rownumbers for both populations, change the last number to be the maximum amount of NA present
SNPtable_1<-SNPtable[,colSums(is.na(SNPtable[1:74,])) <= 54]
SNPtable_2<-SNPtable_1[,colSums(is.na(SNPtable_1[75:114,])) <= 30]
nrow(SNPtable_2)
ncol(SNPtable_2)

## Split up in two tables: B_bufo and B_spino
#again change row numbers for both populations
B_bufo<-SNPtable_2[1:74,]
B_spino<-SNPtable_2[75:114,]

#check if first columns are the right populations
B_bufo[,1]
B_spino[,1]

## Compare the two tables
#Prepare empty matrices (change rownumbers accordingly):
Not_diagnostic_old<-matrix(,nrow=114, ncol=0)
Diagnostic_old<-matrix(,nrow=114,ncol=0)
Not_diagnostic<-matrix(,nrow=114, ncol=0)
Diagnostic<-matrix(,nrow=114,ncol=0)

## Now loop through all SNPs (columns) in this table
for (i in 3:ncol(SNPtable_2)) {
  x_tot<-B_bufo[,i]
  y_tot<-B_spino[,i]
  #compare the two sets of numbers, returns a block with true/false 
  ans<-vapply(x_tot, function(x_tot) x_tot==y_tot, logical(length(y_tot)))
  #if true occurs save in table with not_diagnostic markers
  if(any(ans, na.rm=TRUE)|(all(is.na(y_tot))|all(is.na(x_tot)))){
    Not_diagnostic<-cbind(Not_diagnostic_old, SNPtable_2[,i, drop=FALSE])
    #if only false or NA save in table with diagnostic markers
  } else {
    Diagnostic<-cbind(Diagnostic_old, SNPtable_2[,i, drop=FALSE])
  }
  Not_diagnostic_old<-Not_diagnostic
  Diagnostic_old<-Diagnostic
}

#Summaries and check!
Tot_original<-ncol(SNPtable)-2
Tot_original_B_bufo<-ncol(B_bufo)-2
Tot_original_B_spino<-ncol(B_spino)-2
Tot_not_diagnostic<-ncol(Not_diagnostic_old)
Tot_diagnostic<-ncol(Diagnostic_old)
Tot_not_diagnostic+Tot_diagnostic
Perc_diagnostic<-Tot_diagnostic/Tot_original*100

#Then write the diagnostic snps to a file
write.table(Diagnostic_old, file="RAD_Bufo_Diagnostic.txt", quote=FALSE, sep=" ", col.names=TRUE)
```
Questions: 
How many diagnostic markers do I have?
How many non-diagnostic markers do I have?
Does it add up to the total of markers in the input file?
Where did the other markers go?

Challenge: write a code that takes one SNP per RAD locus randomly
```{r}
#isolate rad names
Uni_names<-unique(gsub("(rad[0-9]+)_.*", "\\1", names(Diagnostic_old)))

#make new table
Diagnostic_random<-matrix(,nrow=114, ncol=0)
new<-matrix(,nrow=114,ncol=0)

#pick the colums with the names, take one random
for (i in 1:length(Uni_names)){
  selection<-Diagnostic_old[,c(colnames(Diagnostic_old)[grep(Uni_names[i],colnames(Diagnostic_old))]), drop=FALSE]
  new<-selection[,sample(ncol(selection), 1), drop=FALSE]
  Diagnostic_random_new<-cbind(Diagnostic_random,new)
  Diagnostic_random<-Diagnostic_random_new
  }
write.table(Diagnostic_random, file="RAD_Bufo_Diagnostic_Random.txt", quote=FALSE, sep=" ", col.names=TRUE)

```

STRUCTURE
  Run structure-like analysis in R (includes some nice mapping options): 
  http://membres-timc.imag.fr/Olivier.Francois/tutoRstructure.pdf
  And:
  https://onlinelibrary-wiley-com.naturalis.idm.oclc.org/doi/pdf/10.1111/1755-0998.12559
  Or:
  https://github.com/Tom-Jenkins/admixture_pie_chart_map_tutorial/blob/master/pie_chart_admixture_map_tutorial.R
  
  Visualisation with Pophelper ###THIS DOESN'T WORK ANYMORE!
  
```{r}
#install packages and dependencies
install.packages(c("ggplot2","gridExtra","gtable","label.switching","tidyr","devtools"),dependencies=T)
# install pophelper package from GitHub
devtools::install_github('royfrancis/pophelper')
# load library for use
library(pophelper)

Struct_table<-read.table("Structure_31SNPs_output_D.txt", header = TRUE)
Struct_table_mtDNA<-read.table("Structure_31SNPs_output_D_mtDNA_2.txt", header = TRUE)
Q1<-list(structure_1=data.frame(Cluster1=c(Struct_table[,3]), Cluster2=c(Struct_table[,4])))
Q2<-list(mtDNA=data.frame(Cluster1=c(Struct_table_mtDNA[,3]), Cluster2=c(Struct_table_mtDNA[,4])))

Pop_label<-Struct_table[,1, drop = FALSE]
Pop_label$Pop <- as.character(Pop_label$Pop)
nrow(Pop_label)

plotQ(qlist=c(Q2[1], Q1[1]), imgoutput='join', clustercol=c("blue", "red"), grplab=Pop_label, grplabsize = 1, showlegend=T, divtype= 1, legendlab=c("Bufo bufo","Bufo spinosus"), splab=c("mtDNA", "Structure"), linecol="white", pointtype=NA, grplabpos=1, imgtype="tiff")

```

##Population genetic analyses in Adegenet

Adegenet
Read in the data & replace missing data with the mean frequency (there are other methods available).
Other file formats are possible, but here we use a structure file.

```{r}
##Read in data
obj1<-read.structure("RAD_Bufo_alldata.str")
##Now you need to fill out the following entries in the command line below
#373, 4836, 1,2, <enter>, 0, n

#Check the populations in obj1
levels(obj1$pop)

#Replace missing data with the mean frequency
NA_mean<-tab(obj1, NA.method="mean")
```

LD

```{r}
##LD2 is for unphased data, LD is for phased data
data(jaguar)
LD2(jaguar, details = FALSE)
LD2(obj1, details = FALSE)
#doesn't seem to work for my own data:
#obj_p1_11<-as.loci(obj1[obj1$pop=="T1_11",1:100])
#LD(obj_p1_11)
```

HW
```{r}
#Do the HW test without the Monte Carlo test
Test_pop_T1_11<-hw.test(obj1[obj1$pop=="T1_11",1:100], B=0)

#Check the output
Test_pop_T1_11

```
Questions:
Why do we have rows with no output?
Why do we have only 43 loci?
  
  
  PCA
  Perform a pca
```{r}
#Do the pca analysis
pca1<-dudi.pca(NA_mean, scannf=F, scale=F,nf=3)

#Make a nice plot
s.class(pca1$li, pop(obj1), axesel=FALSE, cstar=1, cpoint=1, col=c(rep("black", 7),
                                                                   rep("blue", 4), 
                                                                   rep("black", 2), 
                                                                   rep("red", 5), "blue", 
                                                                   "black", "black",
                                                                   rep("black", 12)))
add.scatter.eig(pca1$eig[1:5],3,1,2, ratio=.3, posi="bottomright")

#Display variance explained
summary(pca1)

```

  DAPC & Compoplot
  With adegenet:
  http://adegenet.r-forge.r-project.org/files/tutorial-dapc.pdf

## THE END HAPPY CODING!!